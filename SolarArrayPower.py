import numpy as np
from OrbitalCalculation import get_orbit_times
import math

solar_param_dict = {
    "orbit_altitude": 800000,  # [m] orbital altitude above mars
    "array_power": {
        # [W] power required by spacecraft in nominal
        "power_required_daylight": 800,
        # [W] power required by spacecraft in eclipse
        "power_required_eclipse": 300,
        "path_efficiency_daylight": 0.8,  # [-] total path efficiency daylight
        # [-] total path efficiency eclipse (includes through battery)
        "path_efficiency_eclipse": 0.6,
        "power_required_peak": 900,
        "t_peak": 6 * 60,
    },
    "lifetime_degradation": {
        "lifetime": 5,  # [years] total life time of mission
        # [-] efficiency lost per year of operation
        "degradation_per_year": 0.05,
    },
    "power_per_area_EOL": {
        "angle_of_incidence": 5,  # [deg] worst case angle of incidence
        # [-] fraction of solar incidence captured by array, varies per type
        "power_conversion_efficiency": 0.22,
        # [W/m^2] solar incidence radiation at location
        "solar_radiation_per_area": 604.9,
        # [-] factor to account for the inherent degradation of solar panel
        "inherent_degradation": 0.9,
    },
    "battery_capacity": {
        # [-] fraction of total capacity discharged per cycle
        "depth_of_discharge": 0.3,
        "capacity_per_battery": 5.2,  # [-] number of batteries used
        # [-] efficiency factor for transmission between battery and load
        "efficiency": 0.9,
    },
    "solar_specific": 1.76,  # kg/m^2
    "mass_per_battery": 0.0412,  # kg/m^2
}


def get_path_efficiency():
    n_battery_charge = 0.95
    n_battery_discharge = 0.97
    n_battery = 0.9
    n_array_regulator = 0.96  # transfer efficiency

    n_pcdu_daylight = 0.95
    n_pcdu_eclipse = 0.96 * 0.95

    path_efficiency_daylight = n_array_regulator
    path_efficiency_eclipse = path_efficiency_daylight * \
        n_battery_charge * n_battery_discharge * n_battery
    return path_efficiency_daylight, path_efficiency_eclipse


def get_n_batteries(power_eclipse, power_daylight, power_peak, t_peak, t_eclipse, depth_of_discharge, capacity_per_battery, efficiency):
    # Get the battery capacity in Watt hours

    return math.ceil((power_eclipse * t_eclipse + (power_peak - power_daylight) * t_peak) / (depth_of_discharge * efficiency * capacity_per_battery) / 3600)


def get_area_solar(params):
    t_daylight, t_eclipse, _ = get_orbit_times(params['orbit_altitude'])
    params["array_power"]["t_daylight"] = t_daylight
    params["array_power"]['t_eclipse'] = t_eclipse
    power_solar = get_array_power(**params["array_power"])
    lifetime_degradation = get_lifetime_degradation(
        **params["lifetime_degradation"])
    power_per_area_EOL = get_power_per_area_EOL(
        lifetime_degradation=lifetime_degradation, **params["power_per_area_EOL"])
    return power_solar / power_per_area_EOL, power_solar


def get_array_power(power_required_daylight, power_required_peak, t_peak, power_required_eclipse, t_eclipse, t_daylight, path_efficiency_daylight, path_efficiency_eclipse):
    """
    Computes the power that must be generated by solar cells based on:
    power_daylight - power to be delivered to spacecraft during nominal conditions
    power_eclipse - power to be delivered to spacecraft during eclipse conditions
    t_daylight - time the spacecraft is in nominal conditions
    t_eclipse - time the spacecraft is in eclipse condition
    path_efficiency_daylight - from array to space craft in nominal conditions
    path_efficiency_eclipse - from array to space craft (through batter!) in eclipse condition
    """

    return (((power_required_daylight * t_daylight) / path_efficiency_daylight)
            + (power_required_eclipse * t_eclipse) / path_efficiency_eclipse + (power_required_peak - power_required_daylight) * t_peak / path_efficiency_eclipse) / t_daylight


def get_lifetime_degradation(lifetime, degradation_per_year):
    # Computes total life time degradation factor
    # Lifetime in years
    return (1 - degradation_per_year) ** lifetime


def get_power_per_area_EOL(angle_of_incidence, solar_radiation_per_area, power_conversion_efficiency, inherent_degradation, lifetime_degradation):
    # Compute power per square meter at eng of life
    # angle_of_incidece of solar radiation in degrees!
    # inherent_degradation factor
    # lifetime_degradation factor
    # power_per_area nominal
    power_per_area_0 = solar_radiation_per_area * power_conversion_efficiency
    power_per_area_BOL = power_per_area_0 * inherent_degradation * \
        np.cos(angle_of_incidence / 180 * np.pi)
    return power_per_area_BOL * lifetime_degradation


if __name__ == "__main__":
    panel_area, power_solar = get_area_solar(solar_param_dict)
    print(f"The solar power needed: {power_solar} W")
    print(f"Area of solar panels needed: {panel_area} m^2")
    # In watt hours
    mass_solar = panel_area * solar_param_dict['solar_specific']
    print(f"Mass of solar panels: {mass_solar} kg")
    n_batteries = get_n_batteries(solar_param_dict['array_power']['power_required_eclipse'], solar_param_dict['array_power']['power_required_daylight'], solar_param_dict['array_power']
                                  ['power_required_peak'], solar_param_dict['array_power']['t_peak'], solar_param_dict['array_power']['t_eclipse'], **solar_param_dict['battery_capacity'])
    print(f"Batteries {n_batteries}.")
    print(
        f"Battery capacity: {n_batteries* solar_param_dict['battery_capacity']['capacity_per_battery']} Wh")
    print(
        f"Mass of batteries: {n_batteries * solar_param_dict['mass_per_battery']} kg")
